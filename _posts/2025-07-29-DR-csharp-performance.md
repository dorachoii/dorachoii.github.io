---
layout: post
title: "[Qiita] C#パフォーマンス"
---

## 📖 今日の記事  
[同じ機能、違う書き方 - パフォーマンスで選ぶべきコードはどっち？](https://qiita.com/Sakai_path/items/c51030f1291839025263)

---

## 🗒️ 単語

| 単語                    | 意味              | 文章                                                                                         |
| --------------------- | --------------- | ------------------------------------------------------------------------------------------ |
| 大がかり                  | 큰 일             | プログラムを速くする――と聞くと、「アルゴリズムを大改造する」「マルチスレッド化する」といった大がかりな施策を思い浮かべがちです。                          |
| 演算子(えんざんし)            | 연산자             | `+=`演算子                                                                                    |
| 択一（たくいつ）              | 택일              |                                                                                            |
| 反復（はんぷく）              | 반복              | 複数回の反復処理                                                                                   |
| 削減（さくげん）              | 삭감              | メモリ使用量と処理時間の両方を削減できます。                                                                     |
| スループット(throughput)    | 일정 시간내에 처리된 작업량 |                                                                                            |
| 効く(きく)                | 효과가 있다          | この差がアプリ全体のスループットに効いてくる。                                                                    |
| 縮小(しゅくしょう)            | 축소              |                                                                                            |
| 顕著(けんちょ)              | 현저              |                                                                                            |
| ヒット率(hit rate)        | 캐시 적중률          | 캐시 메모리에 데이터를 요청했을 때, 해당 데이터가 이미 캐시에 저장되어 있어 바로 가져올 수 있는 경우                                 |
| 遅延(ちえん)               | 지연              | ネットワーク遅延                                                                                   |
| 劇的(げきてき)              | 극적              | 劇的な性能向上                                                                                    |
| 潰す(つぶす)               | 부러뜨리다           | 待機時間を“重ねて潰す”                                                                               |
| 揺らぎ(ゆらぎ)              | 흔들림             |                                                                                            |
| 排除(はいじょ)              | 배제              | 実ネットワークの揺らぎを排除するため                                                                         |
| 疑似(ぎじ)                | 유사              | **100 ms の `Task.Delay`** を入れた疑似 API を使用。                                                  |
| 辞書(dictionary)        |                 |                                                                                            |
| ルックアップコスト             | 탐색비용            | 静的な辞書により、ルックアップコストも最小化されます。                                                                |
| 条件木(じょうけんぎ)           | 조건 트리           | これは「タイプ 3 種・金額 3 段」の小さな条件木だったためです                                                          |
| GC ストップ・ザ・ワールド時間(STW) | Stop-The-World  | 가비지컬렉터가 일하면서 어플리케이션 전체가 멈추는 시간                                                             |
| 累乗(るいじょう)             | 거듭제곱            | 汎用的な累乗関数                                                                                   |
| 損なう(そこなう)             | 손상하다            | 過度な最適化は保守性を損なう                                                                             |
| ホットパス(hot path)       |                 | 가장 자주 실행되는 코드 경로나 구간, 처리 시간이나 리소스 소모가 많이 발생해서 성능에 큰 영향을 미치는 구간이라, 최적화가 필요할 때 가장 먼저 집중하는 대상 |

---

## 💡 インサイト

- プログラムを速くする――と聞くと、「アルゴリズムを大改造する」「マルチスレッド化する」といった大がかりな施策を思い浮かべがちです。しかし実際には、日常的に書いている **ちょっとしたコードの選択** が、そのままアプリ全体の体感速度を左右しているケースも少なくありません。
- 最適化のゴールは 「闇雲に速くする」 ことではなく、「**可読性・保守性とのバランスを取りながらベストプラクティスを選ぶ**」ことだということは忘れないでおきましょう。

| 項目    | 直列 + 非同期             | 並列 + 非同期<br>(병렬: 논리적 동시성을 의미) |
| ----- | -------------------- | ----------------------------- |
| 処理順序  | 順番に一つずつ処理            | 複数の処理を同時に実行                   |
| リクエスト | 1件ずつ送信 → 応答待ち → 次へ   | 全て同時に送信 → 応答順に処理              |
| 処理時間  | リクエスト数 × 各リクエストの所要時間 | 最も時間がかかるリクエストの時間              |
- “増えそうな分岐は最初からテーブル設計” を意識してみてください。

| 項目        | ヒープ（Heap）                 | スタック（Stack）                            |
| --------- | ------------------------- | -------------------------------------- |
| メモリ割り当て方式 | `new` などでランタイム中に動的に割り当て   | `stackalloc` などで事前に静的に割り当て             |
| 例         | `var arr = new int[100];` | `Span<int> arr = stackalloc int[100];` |
| 管理主体      | ガベージコレクタ（GC）              | 呼び出し終了時に自動で解放（フレーム単位）                  |
| 速度        | 遅い（GCの処理が必要）              | 速い（LIFO方式で高速）                          |
| ライフサイクル   | 参照がある限り保持される              | 関数のスコープ終了時に自動的に破棄される                   |
- `Math.Pow(x, 2)`は汎用的な累乗関数のため、単純な`x * x`より重い処理になります。
- C#の多次元配列は行優先（row-major）でメモリに配置されるため、行優先でアクセスすることでCPUキャッシュヒット率が向上します。
- パフォーマンス最適化は、アルゴリズムの理解、メモリ使用パターンの把握、そしてC#/.NETの内部動作に関する知識がとても大切です。