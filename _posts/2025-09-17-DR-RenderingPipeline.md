---
layout: post
title: "[UnityPerformanceTurningBible] 2.2 Rendering"
---

## 📖 今日の記事  
[UnityPerformanceTuningBible](https://github.com/CyberAgentGameEntertainment/UnityPerformanceTuningBible/releases/tag/v1.0.5)

---

## 🗒️ 単語

| 単語        | 意味      | 文章                          |
| --------- | ------- | --------------------------- |
| 増大(ぞうだい)  | 증대      | 処理負荷が増大します。                 |
| 留める(とどめる) | 멈추다     | 簡易的な説明に留めます。                |
| 透けて(すける)  | 비쳐 보이다. | 奥側のオブジェクトが透けて見えていなければ不自然です。 |


---

## 💡 インサイト

- コンピュータグラフィックスでは、3D モデルの頂点座標やライトの座標と色などの データに対して一連の処理を行なうことで、最終的に画面上の各画素に出力する色を 出力します。この処理の仕組みを==レンダリングパイプライン(Rendering Pipeline)==と呼びます。
- 3D モデルの頂点座標やカメラの座標、向き、画角など それぞれ個別のデータです。GPU はこれらの情報をまとめて「そのカメラでそのオブ ジェクトを映した場合に、画面上のどの位置にオブジェクトが表示されるか」を計算 して求めます。この処理を==座標変換==と呼びます。
- まずこれらのオブジェクトが両方とも不透明であるケースを考えます。この場合、カ メラから見て手前にあるオブジェクトから順番に描画処理が行われます。こうすると、 奥側のオブジェクトを描画する際に、手前のオブジェクトに重なって見えていない部 分は処理する必要がありません。つまりこの部分はフラグメントシェーダーの演算を スキップできるということになり、結果として処理負荷を最適化できます。
- もし画面いっぱいに描画される半透 明なオブジェクトが 2 つ存在していたら、画面いっぱい分の処理が 2 回行われるとい うことになります。このように、半透明なオブジェクトを重ねて描画することを==オー バードロー(overdraw)==と呼びます。オーバードローが多すぎると GPU に大きな処理負荷がかか り、パフォーマンスの低下に繋がるため、半透明描画を行う際には適切にレギュレー ションを設ける必要があります。
- オブジェクトをレンダリングする際には CPU から GPU に描画するた めの命令を出します。これは==ドローコール(Drawcall)==と呼ばれ、レンダリングするオブジェクト の数だけ実行されます。
- またこのときに、テクスチャなどの情報が前回のドローコー ルで描画したオブジェクトのものと異なっている場合には、それらを GPU に設定する 処理を行います。これは==セットパスコール(Set pass call)==と呼ばれ、比較的重い処理になります。
- Unity には、ドローコールを削減するために==ドローコールバッチング(Drawcall Batching)==と呼ばれる仕組 みが実装されています。これは同じテクスチャなどの情報、つまり同じマテリアルを 持つオブジェクトのメッシュをあらかじめ CPU 側の処理で結合してしまい、1 回のド ローコールで描画する仕組みです。
- バッチングに似た効果を得られる機能として、==GPU インスタンシング(GPU Instancing)==があり ます。これは GPU の機能を使うことで、同じメッシュを持つオブジェクトを 一度のドローコール・セットパスコールで描画できる機能です。
